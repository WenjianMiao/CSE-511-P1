This project is done by students Wenjian Miao  &   Yilei Lin

file description
./config/path.lex   ./config/path.y   		the lex-format and parse-format code used by flex and bison
./src/path.lex.c    ./src/path.yacc.c 		the lexical analysis and parsing analysis code. Automatically generated by flex and bison.
./src/path.yacc.h   		      		the token table for parsing.
./src/support.c     		      		some support function for pe_sync
./inc/global.h      		      		global token shared by all the code.
./chid_care_bonus.c      	      		source code for bonus.
./child_care_bonus_test.bin           		executable code for bonus
./TestInputs/child_care_bonus_small_test_input  a sample test input for bonus
./TestOutputs/child_care_bonus_small_test_output a sample test output for bonus
README.txt					this file

Using "make" to build the project.
Using "make clean" to clean the project.


Project Analysis:
In this project, we first need to generate a parser for any input of Path Expression. We need first extract restricted operation for every path-end. And then to construct an Finite State Machine(seems like an AST) to descirbe our Path Expression. So I use the tools of flex and bison to help me generate this parser.

And then we should implement the sync function. Our idea is that when an operation ENTER, we first lock(), and then using enter_test() to check if it can do operation. If not, we need cond_wait() and then enter_test() again until we pass the test(That means we can do this operation). When pass the test, we need do some state transfrom using prep_run(). And then unlock().   When an operation EXIT, we first lock(), and then we need do some state transfrom using after_run(). And then cond_signal() to all waiting thread. And finally unlock().   I put the code here.

void ENTER_OPERATION(const char *op_name)
{
	pthread_mutex_lock(&m);
	
	int if_enter = enter_test(op_name); 
	while(!if_enter){
		pthread_cond_wait(&c,&m);
		if_enter = enter_test(op_name);
	}
	pre_run(op_name);
	pthread_mutex_unlock(&m);
}

void EXIT_OPERATION(const char *op_name)
{
	pthread_mutex_lock(&m);
	after_run(op_name);
	pthread_cond_broadcast(&c);
	pthread_mutex_unlock(&m);

} 

And in INIT function of pe_sync.c, we just need to use the Path Expression to construct the Finite State Machine for us to use.


For child_care problem, we want to maintain the share variable of numGiver and numChild. So we need the path numGiver + numChild end to convey that we can only modify one at a time. And then we need to check when the child arrive and when the giver leave. If child wants to arrive but no giver here, the child should wait for enter. If giver wants to leave but he is the last giver and there still have some child, then the giver should wait. We use the numGiver and numChild to check this condition.

For bonus, we just need to modify the check condition.

And I use the Start time as the real enter time, so you can ignore the End time.
